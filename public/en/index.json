


[{"content":"","date":"23 October 2025","externalUrl":null,"permalink":"/en/series/choco-charlie/","section":"Series","summary":"","title":"Choco Charlie","type":"series"},{"content":"","date":"23 October 2025","externalUrl":null,"permalink":"/en/tags/gameboy/","section":"Tags","summary":"","title":"Gameboy","type":"tags"},{"content":"","date":"23 October 2025","externalUrl":null,"permalink":"/en/tags/hardware/","section":"Tags","summary":"","title":"Hardware","type":"tags"},{"content":"","date":"23 October 2025","externalUrl":null,"permalink":"/en/tags/history/","section":"Tags","summary":"","title":"History","type":"tags"},{"content":"","date":"23 October 2025","externalUrl":null,"permalink":"/en/tags/indiedev/","section":"Tags","summary":"","title":"Indiedev","type":"tags"},{"content":"Using sprites looked promising, but it still wasn’t working — I needed to reduce their usage somehow.\nThat’s when, while reading more about the Game Boy’s architecture, I stumbled upon something that seemed like salvation — something the engineers had left there to save my life (well, not really): the window, a second, alternate tilemap.\nThe window sounded like everything I’d ever dreamed of. Another graphical layer that moves independently of the sprites and the background? And on top of that, it can be drawn over the others?\nThat meant I could move one part of the screen independently from the rest.\nI just needed to place the window strategically over part of my board and, between the background scroll and the sprites… surely I could make everything move separately however I wanted.\nBut as I started learning more about the window, I realized things wouldn’t be that easy.\nThe window has two serious limitations: the first is that it’s not really a true layer — it has no transparency, and its draw order can’t be changed. It always takes priority over the background.\nThe second: it can’t be placed just anywhere on screen.\nGame Boy titles often used the window layer for HUDs or pause menus.\nSource: Game Boy Graphics \u0026amp; How To Code Them (2:17) by NesHacker\nThe window actually overwrites the portion of the screen where it’s active, and that area can’t be arbitrary — it must cover everything from a given X,Y position to the bottom-right corner of the Game Boy’s display.\nThat makes it impossible, practically speaking, to position it only on the left side of the screen.\nHowever, by manipulating the registers mid-frame, it is possible to make it cover partial vertical regions — for example, just the top half of the screen, or leaving a gap between top and bottom sections.\nTaking all these limitations into account, I started running (mental) experiments to see how I could cover every possible block-pushing scenario.\nA bit of advice: don’t do this — just start coding. You’ll reach the same conclusion much faster.\nBut following my own delusion, I began imagining the nastiest corner cases. For example: what if I only wanted to move the blocks in the center of the board but not the ones on the sides?\nWell, in that case, sprites could come to the rescue.\nBut what if I only wanted to move one or two blocks? Then I’d have to do the opposite — use moving sprites and a static background, sure, but then…\nThat’s where my brain started to melt.\nWhile it might be technically possible to cover most cases by strategically using all three tools (Sprites, Background, and Window), there was no guarantee that some edge case wouldn’t break everything.\nAnd in the best-case scenario, I’d end up with a graphics engine built out of patches and hacks — completely unmaintainable.\nNo… it had to be simpler, more consistent. I needed internal coherence.\nOnce again, the hardware didn’t seem made for my game; I felt like a kid trying to build a Game Boy out of LEGO pieces.\nWas I asking for too much? Maybe.\nBut there was one idea that had been floating around in my head for a while — I had a plan: partial scroll to the rescue.\nLet’s pause for a second to explain once again how the PPU rendering mode works on the Game Boy.\nGraphics are drawn line by line, from top to bottom, just like a CRT display from that era.\nThis design intentionally mimics the NES development model, including the waiting periods between lines (hblank) and after the full frame has been drawn — vblank, which we already mentioned in the previous post.\nAt each of these moments, the console triggers an interrupt to indicate that it’s entering one of these phases — either hblank or vblank.\nThis is useful because these are the only safe times to copy new tiles into video memory — whether into the tilemap or the tileset.\nBut they can also be used to create mid-frame effects, like changing the scroll speed on a specific scanline to simulate depth or parallax.\nExample: Batman: Return of the Joker for NES uses mid-frame techniques to create an impressive parallax effect.\nIn my case, where entire rows or columns of blocks need to move, such an effect would be extremely useful.\nI could simply adjust the scroll on a few lines instead of having to copy new tiles into the background every time the player dragged a column.\nThe problem was that this would only work for rows of blocks — not columns — since the Game Boy has no way to trigger interrupts at arbitrary vertical positions within a frame.\nStill, in theory, it would be possible to synchronize with the rendering time of each line to modify the scroll registers at a specific horizontal position.\nModern documentation briefly mentions this possibility, but makes it very clear that trying to manipulate graphics while each line is being drawn is extremely risky.\nThe Pan Docs provide detailed information about the PPU’s timing, even describing how it can vary slightly between lines.\nAnd that, my friends, is the problem: the PPU’s line rendering time isn’t constant — and that’s one of the main reasons why synchronizing with it is so difficult.\nIt took me a while to realize that the registers controlling scroll weren’t actually bound by this limitation.\nEven so, the documentation warned that manipulating them at that point was incredibly tricky and often unstable.\nLater I’d learn why, but let’s not get ahead of ourselves.\nAt that point, I was still thinking about using a combination of techniques.\nI planned to run tests to see how far I could really control the scroll registers, but since that had to be done in assembly, and I hadn’t even written my first hello world in that language yet, I kept putting it off for quite some time.\nAnd so, years passed with no real progress — until the events I mentioned in my first post happened: losing my job, and discovering that piece of code — Canyon Racer — which proved that it was indeed possible to manipulate a horizontal partial scroll, even if only under very limited conditions.\nIn the next post, I’ll show how I finally started programming — initially just to quiet my obsession and see if my idea was even possible, but ending up with a pretty slick technical demo.\nResources mentioned:\nGame Boy Graphics \u0026amp; How To Code Them - NesHacker · PanDocs · Canyon Racer\n","date":"23 October 2025","externalUrl":null,"permalink":"/en/posts/gameboy-window-scroll/","section":"Posts","summary":"How I managed to make things even harder for myself","title":"Looking for a way out: the window, sprites, and scroll","type":"posts"},{"content":"","date":"23 October 2025","externalUrl":null,"permalink":"/en/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"23 October 2025","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"23 October 2025","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"Alright then — here’s what really matters: I want to move blocks.\nThe Game Boy can move tiles, right? So\u0026hellip; how many at once?\nThe trick answer is: “all of them.”\nAs we’ve already discussed, the Game Boy can scroll its tilemap (the background). That means it can technically “move” almost four times as many tiles as are visible on screen — essentially the entire tilemap. But here’s the catch: those tiles must already be loaded into that section of memory. And this is where the trick lies — the loading process, while extremely fast by the standards of its time (since it copies entire tiles rather than individual pixels), is rather slow by modern standards.\n“Slow” is, of course, relative — but you have to remember that the video memory can’t be manipulated all the time. It can only be written to during very specific periods in the rendering cycle: vblank or hblank.\nThe Game Boy runs at a fixed 60 frames per second. If you don’t finish copying all the necessary tiles during that window, you’ll have to wait for the next frame to complete the task.\nGame Boy PPU rendering cycle for a single frame. Source: The Ultimate Game Boy Talk (44:39)\nThis is why most games that load new map areas — whether the scroll is vertical, horizontal, or both — use algorithms that load small parts of the tilemap during the brief vblank period, creating the illusion of new graphics while keeping the effective scrolling speed limited.\nEven something as “simple” as a screen transition in The Legend of Zelda: Link’s Awakening isn’t trivial. It uses short pauses disguised with visual effects to mask loading time. The story of how Nintendo and other studios managed to pull off “Zelda-style” games on the Game Boy is fascinating — definitely worth a read. It wouldn’t be until much later that games like Donkey Kong Land achieved the holy grail: true bidirectional scrolling in real time.\nSo yeah, something as innocent as “I want to push any number of blocks freely on a grid” can quickly turn into a pipe dream.\nLet’s refine the question: how many new tiles are we talking about? Do we need to update the entire game board at once?\nIf we’re talking about moving any number of tiles — even from one cell (A) to its neighbor (B) — we already have a problem. So let’s go back and review how the Game Boy actually works.\n(Well, this will actually be the first time I try to explain it properly.)\nThe Game Boy’s screen resolution is 160×144 pixels, which equals 20×18 tiles. To give scrolling games some breathing room for loading new data, the engineers decided (wisely) that a tilemap of 32×32 tiles — about 1.5–1.8 times the visible screen area — would be enough.\nExample of the visible part of the tilemap given specific SCX SCY scroll positions. Source: Game Boy Graphics \u0026amp; How To Code Them 2:58 (NesHacker)\nThe tilemap can be filled with tiles from another section of PPU memory called the tileset. Think of it as a library where tiles are stored before being drawn on the background.\nThis library isn’t infinite either — it can hold about 384 tiles, though only around 256 are usable at a given time. This limits our flexibility: if we had an “infinite” tileset with precomputed tiles for every position, we could trade CPU time for memory — a classic performance trick. But let’s not get ahead of ourselves.\nIn practice, the Game Boy can copy about 80 new tiles per frame from the tileset to the tilemap — maybe a bit more if memory alignment is perfect, but that only helps in specific cases.\nBack to my game: that would make block movement feel very choppy for two reasons.\nFirst, blocks would only move in 8-pixel steps (1 tile).\nAnd second, to cover most cases without slowdown, I’d need to run a virtual 30 FPS render loop that uses real 2-frame render batches to double the number of tiles copied per logical frame — around 160 tiles.\nAnother valid option would be to target the tileset instead of the tilemap — or both. When you swap one tile in the tileset for another, it instantly affects every instance of that tile on the map.\nSo the idea would be to smooth movement by precomputing intermediate push positions for each block — maybe including the empty space or its neighbor, depending on direction. That’s an optimization by precalculation in memory.\nIn practice, though, it only makes movement smoother while also much slower, since updating the tileset itself is extremely slow. Even at its best, it can only update about 4 tiles per frame, assuming aligned memory.\nOn the other hand, we have sprites — which don’t suffer from these tilemap limitations.\nSprites are small independent objects, 8×8 or 8×16 pixels (you can pick one mode or the other, but not both). In other words, one or two stacked tiles.\nSprites can be positioned anywhere on screen — they don’t need to align to the background grid — and they can move freely between tile positions without touching tile memory. You can also have plenty of them on screen with very little performance cost, since the PPU handles them automatically using a reserved area called OAM (Object Attribute Memory). Sprites can be updated efficiently via OAM DMA transfers. In short, the Game Boy was specifically designed to bring these little independent objects to life.\nCopying all the data from the 40 sprites back to the OAM using DMA (Direct Memory Access) and thus modifying their position is very fast and can be done in a single frame, allowing plenty of time. Source: Game Boy Graphics \u0026amp; How To Code Them 5:58 (NesHacker)\nSo, back to my obsession with pushing blocks:\nImagine a Zelda-like scenario. If I wanted to move a single block — or even 40 blocks at once (the maximum number of sprites) — could I use sprites for that? Wouldn’t that be enough for my game?\nThe answer is no.\nLet’s imagine sprites are 8×8 pixels. If I fill the screen with them to create my playfield — say, a 5×5 grid — that gives me a tiny 40×40-pixel board. And then what? I’ve run out of sprites, and I still have the rest of the screen to fill!\nBesides, 5×5 blocks would make for a very small, limited puzzle game.\nSome puzzle games like Tetris or Dr. Mario use single-tile blocks, but those designs are built around a small active area (the falling pieces) rendered as sprites, while the rest of the board is a static tilemap background.\nApart from the lack of visual appeal, small sprite blocks wouldn’t give me much flexibility for gameplay mechanics. If I needed even one extra sprite for an animation — too bad. In short: lots of problems, few advantages.\nThe kind of game I had in mind was closer to Yoshi’s Cookie or Panel de Pon (Tetris Attack).\nThose games use metatiles — groups of tiles that form a single visual element, like a reusable part of the background or a multi-tile sprite. Both Yoshi’s Cookie and Panel de Pon use 16×16-pixel (2×2 tile) metatiles for better detail and visibility.\nThat means to create even a 5×5 board, I’d already be in trouble — I’d need four times as many sprites (or double that if using 8×16 mode). And as we said, even a 5×5 grid limits the gameplay.\nWhat I really wanted was at least a 7×7 grid of big, chunky, colorful blocks — moving smoothly in any direction, in any number. And I wanted it now. (And maybe a paella, too.)\nIn the next entry, we’ll see how that stubbornness led me to explore other corners of the Game Boy’s architecture — bending every rule I could to make my game possible in the most convoluted ways imaginable, while conveniently forgetting the golden rule of serious software development: keep it simple!\nResources mentioned:\nThe Ultimate Game Boy Talk - 33c3 · Game Boy Graphics \u0026amp; How To Code Them - NesHacker\n","date":"20 October 2025","externalUrl":null,"permalink":"/en/posts/gameboy-architecture/","section":"Posts","summary":"Understanding the Game Boy’s architecture","title":"Pushing Blocks Is... Complicated","type":"posts"},{"content":"In architectural terms, the Game Boy is a far more advanced machine than the Nintendo NES.\nEven though it was a portable console — and in some aspects less powerful due to its focus on energy efficiency — many of the lessons learned from the NES were carried over and perfected on the Game Boy. At the same time, it preserved the same development paradigms, and this was no accident. It was done intentionally, among other reasons, to make life easier for developers who had grown alongside the NES architecture and were now stepping into the new age of modern video games.\nUnlike earlier machines that were closer to micro computers, the Game Boy graphics system, like the NES, had its own dedicated video memory (named vram), completely focused on processing tiles (graphic blocks of 8×8 pixels).\nUnder this scheme, the console could create games as rich and varied as Link’s Awakening or Kirby’s Dream Land, featuring smooth scrolling backgrounds. Alongside that fine background scroll, it also had a reserved area for actors or sprites — representing the player, enemies, and other interactive elements. There was even an alternate background layer intended for the HUD, which made life so much easier for development teams.\nThe tileset is the raw material to build the gameboy graphics The ppu creates the tilemap (background) using the tileset as a source It also can use the tileset to store 40 independent objects or sprites The console also had one advantage over the NES: its low resolution. The maximum number of sprites per screen (40, slightly less than the NES’s 64) actually covered a larger portion of the display area, relatively speaking.\nThere were also quality-of-life improvements, such as more precise control over the horizontal video rendering process — making graphical tricks that required a lot of effort on NES, like parallax backgrounds, almost feel like native features on Nintendo’s new handheld.\nIn short, the Game Boy was like a portable NES — a bit less powerful in raw terms, but completely optimized for the kind of games that were popular at the time. That’s why Game Boy programmers quickly managed to make things look easy that had once been difficult during the NES’s early days, eventually crafting genuine 8-bit engineering masterpieces by the end of the console’s life.\nI think that’s what made me believe my game idea was actually possible. I looked at games like Yoshi’s Cookie and Tetris Attack (Panel de Pon) and saw them doing things that seemed similar to what I wanted to achieve.\nWhat I didn’t know was that those games were full of graphical tricks, pushing the hardware to its absolute limits — even more so than seemingly “bigger” titles like Pokémon or Zelda.\nPuzzle games had never been as popular as they became after the release of Tetris for Game Boy in 1989–1990, something that, in my opinion, even caught Nintendo off guard. They quickly created the Dr. Mario franchise as an attempt to compete with the tetromino fever — or at least to ride that same wave of success.\nComing from much older and weaker machines, it wasn’t that hard to port Tetris to the Game Boy — but that doesn’t mean the console was specifically designed for that kind of game.\nStill, the market had spoken: people wanted more puzzle games for Game Boy. That’s why we can find incredible feats of engineering in those titles I mentioned — games that in some ways go against the system’s original architectural intent, yet at the same time are cleverly designed around its limitations, with lessons learned from the very Tetris port that started it all.\nHere’s a fantastic tutorial on how to make your own Game Boy Tetris in GBDK by Larold’s Retro Gameyard, featuring a design approach similar to what developers used back in the day.\nSo yeah — I had chosen a difficult genre for my homebrew project.\nAnd to make things worse, most of the documentation and examples you can find online today focus on those “easy” genres — RPGs or action RPGs like Zelda and Pokémon, or platformers like Super Mario Land.\nThose are the types of games the system was originally designed for, and nowadays there are even dedicated engines like ZGB or GB Studio that make developing them much easier.\nAt this point, any sensible engineer would have probably thought, “This doesn’t belong here,” and moved on — or at least reworked the idea to fit within the platform’s limits.\nBut I’m not a sensible engineer.\nIn fact, I’m not really an engineer at all.\nFollow me in this mad adventure in the next entry of the blog, where we’ll once again try to make my game possible on the Game Boy.\nResources mentioned:\nLarold’s Retro Gameyard · ZGB Engine · GB Studio\n","date":"17 October 2025","externalUrl":null,"permalink":"/en/posts/gameboy-graphics/","section":"Posts","summary":"Making puzzle games for Game Boy is hard!","title":"Game Boy, the Perfect Handheld NES","type":"posts"},{"content":"","date":"17 October 2025","externalUrl":null,"permalink":"/en/tags/indidev/","section":"Tags","summary":"","title":"Indidev","type":"tags"},{"content":"","date":"17 October 2025","externalUrl":null,"permalink":"/en/tags/lifehacks/","section":"Tags","summary":"","title":"Lifehacks","type":"tags"},{"content":"","date":"17 October 2025","externalUrl":null,"permalink":"/en/tags/offtopic/","section":"Tags","summary":"","title":"Offtopic","type":"tags"},{"content":"For seven years, an idea had been haunting me — a Game Boy puzzle game where a little character would push blocks freely across the screen to form shapes.\nWhy had no one done something like that before? It seemed so obvious to me that it would work. I was naïve back then — and I still am. That’s what brought me here. I hope I’ll always stay naïve.\nThe most obvious question one might ask after reading such a simple premise is: why did I become so obsessed with this idea? It wasn’t the first time I’d come up with a game concept. Like any creative person with dreams of making games someday, I had built up an endless list of unmade projects over the years — all sorts of ideas, some even simpler or more promising than this one.\nSo what made this particular idea survive for so long and, against all odds, eventually become real?\nI think I know the answer, and I call it — somewhat ironically — motivational synergy.\nProcrastination master? Maybe this idea will “help” you 🙂 (it won’t, actually).\nEver since I was a kid, I dreamed of making video games — but there was another dream intertwined with that one: making them for retro consoles. My first console was a NES, bundled with Blue Shadow (Shadow of the Ninja in the US), Super Mario Bros. 3, and Mega Man 3. Three masterpieces that left my five-year-old self completely mesmerized. I still haven’t recovered.\nSuper Mario Bros. 3 Mega Man 3 Blue Shadow (Shadow of the Ninja) To this day I’m still hooked on retro gaming — especially the 8–16 bit era. That’s how, after seeing games like Mr. Driller for Game Boy Color, I told myself my idea had to be possible on that console. It was perfect for it: a simple concept with no complex controls that fit perfectly with the Game Boy’s philosophy.\nI dreamed of blending ideas from Bomberman, Mr. Driller, Tetris Attack, and even Candy Crush, yet somehow creating something that felt new, fresh, almost inevitable. That absurd mix, paired with the direct and minimalistic aesthetic of the Game Boy, made my imagination run wild.\nMr. Driller Yoshi’s Cookie Tetris Attack For some reason, I was convinced the game could be done on that system. I just knew it. And yet, the more I learned about the Game Boy’s inner workings, the harder it seemed — a huge wall stood between my idea and me. But instead of discouraging me, it only made the challenge more enticing.\nThat’s where the so-called synergy comes in. I have a pretty intense ADHD-type brain; I need an almost absurd level of motivation to move forward with something, even if I love it. And even then, I always find an excuse not to do it. Over time, I’ve learned to spot those rare situations where I can hack myself — use my own distractions as fuel. This was one of those.\nI could channel all that restless energy into learning more about the platform, exploring the Game Boy dev community, and absorbing its ecosystem. Meanwhile, I could keep procrastinating. Not make the game yet. Because I “wasn’t ready,” right?\nI talked to a few people in the community and clumsily explained my idea. Most told me it was nearly impossible, that I should forget it and start with something simpler. Which, of course, made it irresistible.\nOh, it can’t be done? Hold my beer.\nBut they were right. I started testing different engines: GBDK, ZGB Engine (back then GB Studio didn’t exist yet). I quickly realized none of them were built for what I had in mind.\nI won’t dive into technical details just yet, but in my head, the game involved tons of blocks moving freely, pushing each other smoothly across the board.\nYeah, not exactly trivial. If I wanted it to work, I’d have to go down to assembly language.\nWhat a nightmare. I hadn’t touched assembly since college, and even though I knew I could handle it, my procrastination skills are legendary.\nSo I went back to my old routine: read more docs, watch more examples, more videos, think up new engine strategies… and still write zero lines of code.\nAnd you know what? In the end, my method did pay off — at least if you ignore the tiny detail that it took seven years to start. Nobody said it had to be fast 😂.\nBut honestly, it’s not that it worked slowly — it just doesn’t work.\nThe core of my so-called “motivational synergy” (also known as systematic avoidance) is that you never actually get around to executing the idea that sparked your will in the first place.\nAnd yet, that endless loop eventually broke. Not because of me, but because of life itself.\nDuring that time, my career as a full stack developer was going great, riding the wave of the cross-platform app boom. Project after project, paycheck after paycheck, I fell deeper into a kind of workaholism that left me with no time for anything else.\nUntil, at the beginning of this year (2025 — for whoever’s reading this in the glorious age of AI, which I sincerely doubt), the bubble burst. And with it, my job.\nAlmost simultaneously, something happened that now feels providential.\nOne day, during yet another one of my routine research sessions on how to make my idea possible, I stumbled upon a demo called Canyon Racer.\nIt was made in GBDK — yay, no assembly! — and most importantly, it contained the very trick that could make my dream possible: varying the scroll speed mid-scanline.\nWhy was that so important? I’ll explain it in detail in future posts, but to sum it up: after years of mentally sketching solutions, I’d realized that this graphical trick was the one thing that could make my “impossible” game possible.\nThat had to be the sign I’d been waiting for. I was out of excuses. I had to give it a shot.\nAnd that’s how my journey began. But before diving into the development process itself, I’d like to dedicate the next entry to explaining, in my own way, the graphical limitations of the Game Boy.\nIt won’t be a technical manual, but a personal account of how I see that wonderful little machine.\nAnd if this story helps someone else take the plunge — hopefully faster than I did — then I’ll consider it a success.\nResources mentioned:\nAwesome Game Boy · Gbdev Community · GBDK 2020 · RGBDS · ZGB Engine · GB Studio · Canyon Racer\n","date":"17 October 2025","externalUrl":null,"permalink":"/en/posts/the-beginnings-the-project-that-never-starts/","section":"Posts","summary":"How it took me 7 years to start making my Game Boy game","title":"The Beginnings: The Project That Never Starts","type":"posts"},{"content":"I work in Choco Charlie and other indi dev projects. Willing to share my little knowledge of retro development with anyone who is interested. Feel free to contact me if you want to know more!\n","date":"17 October 2025","externalUrl":null,"permalink":"/en/","section":"TripleC Blog","summary":"","title":"TripleC Blog","type":"page"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]