


[{"content":"Lo de mover sprites resultaba prometedor, pero de momento no funcionaba; necesitaba reducir el uso de sprites de algún modo. Es entonces cuando, leyendo más sobre la arquitectura de Game Boy, me topé con algo prometedor, algo que los ingenieros habían dejado allí para salvar mi vida (en realidad, no): la ventana, un segundo tilemap alternativo.\nLa ventana parecía todo lo que había podido soñar. ¿Otra capa de gráficos que se mueve independientemente de los sprites y el fondo? ¿Y encima se puede colocar sobre la otra? De este modo podría empujar una parte de la pantalla independientemente del resto. Solo tenía que poner la ventana estratégicamente en una parte de mi tablero y, entre el scroll del fondo y los sprites… Malo será que no consiga moverlo todo por separado arbitrariamente.\nPero a medida que empezaba a aprender más sobre la ventana, me di cuenta de que esto no sería tan fácil. La ventana tiene dos limitaciones serias: la primera es que realmente no es una capa como tal; no tiene transparencias ni se puede elegir el orden en el que se dibuja —siempre va a tener prioridad respecto al background—; la segunda es que tampoco se puede colocar en cualquier lugar de la pantalla.\nLos juegos de Game Boy solían usar la ventana para el HUD y menús de pausa. Fuente: Game Boy Graphics \u0026amp; How To Code Them 2:17 (NesHacker)\nLa ventana realmente sobrescribe la parte de la pantalla donde está activa, y esa parte no puede ser cualquier parte: tiene que ser todo el espacio desde una cierta posición X,Y hasta el final de la pantalla de la Game Boy. Esto hace imposible, a efectos prácticos, colocarla cubriendo solo la parte izquierda de la pantalla; sin embargo, manipulando los registros a medio frame, sí es posible hacer que cubra parcialmente regiones en sentido vertical, es decir, mostrarla solo en la parte superior o dejar un hueco entre la parte superior y la inferior.\nTomando todas estas limitaciones en cuenta, empecé a hacer experimentos (mentales) para ver cómo podía cubrir todos los casos de empuje de bloques. Un consejo: no hagáis esto y mejor poneros a programar. Vais a llegar a una conclusión mucho más rápida.\nPero siguiendo con mi delirio, empecé a imaginar corner cases de lo más problemáticos. Por ejemplo: ¿qué pasaría si solo quisiera mover los bloques de la parte central del tablero, pero no los de los extremos en sentido horizontal? Bueno, en ese caso los sprites podrían volver al rescate. Pero ¿Y si solo quisiera mover uno o dos bloques? Entonces habría que hacer lo contrario, sprites móviles y fondo estático, claro, pero entonces…\nAquí me empezaba a explotar la cabeza. Si bien sería técnicamente posible cubrir la mayoría de los casos usando estratégicamente los tres recursos (Sprites, Background y Ventana), nadie me aseguraba que no hubiera algún corner case imposible de cubrir. Y en el mejor de los casos, acabaría con un motor gráfico hecho a base de parches y excepciones imposible de mantener.\nNo… La cosa tenía que ser más sencilla, más consistente; necesitaba coherencia interna. Una vez más, la máquina no parecía estar hecha para mi juego; me sentía como un niño tratando de construir una Game Boy con piezas de LEGO.\n¿Estaba pidiendo demasiado? Quizás sí, pero había una idea que me había estado rondando por la cabeza desde hacía tiempo; tenía un plan: el scroll parcial al rescate.\nHay que detenerse un momento aquí para explicar otra vez cómo funciona el modo de renderizado de la PPU de Game Boy. Los gráficos en Game Boy se dibujan línea por línea de píxeles, de arriba a abajo, tal como lo haría una CRT de la época. Esto se hace, una vez más, para mantener el mismo esquema de desarrollo que en NES, imitando también el tiempo de espera entre líneas llamado hblank y el tiempo de espera tras el dibujado total de la pantalla, que ya hemos mencionado en el anterior post: vblank.\nEn cada uno de estos momentos, la consola lanza una interrupción para indicar que está procediendo a cada una de estas fases, tanto en hblank como en vblank. Esto es útil porque en esos periodos es cuando es seguro copiar nuevos tiles a la memoria de video de la consola, ya sea al tilemap o al tileset. Pero también se puede usar para crear efectos que generen cambios a mitad de pantalla, como cambiar la velocidad de scroll en una determinada scanline para generar efectos de profundidad o parallax.\nEjemplo: en BATMAN: Return Of The Joker para NES se usan estas técnicas midframe para crear un efecto parallax imponente\nEl caso es que mi juego, donde se mueven filas o columnas de bloques, se vería ampliamente beneficiado por un efecto así, pudiendo usar simplemente scroll en unas cuantas líneas en vez de tener que copiar nuevos tiles al background cada vez que el usuario arrastrara una columna. El problema es que eso solo iba a servir para filas de bloques y no para columnas, porque la Game Boy no tiene modo de generar interrupciones en posiciones verticales arbitrarias en cada frame.\nAun así, en teoría sería posible sincronizarse con el tiempo de dibujado de cada una de las líneas para cambiar los valores del scroll en una posición determinada en el eje horizontal. La documentación disponible hoy en día menciona de manera muy resumida esta posibilidad, pero deja muy claro que intentar manipular gráficos durante el dibujado de cada línea es muy peligroso.\nLos PanDocs de Game Boy ofrecen además información detallada sobre el timing de la PPU e incluso contienen información de cómo varía el timing. Porque sí, amigos, aquí radica el problema: el tiempo de renderizado de cada línea por la PPU es variable, y ese es uno de los motivos principales de su dificultad a la hora de sincronizarse con él.\nMe costó algún tiempo comprender que los registros que controlan el scroll no formaban parte de esta restricción; aun así, también se insistía en que intentar manipular esos registros en ese punto era tremendamente complicado e incluso inestable. Más adelante comprendería el porqué, pero no nos adelantemos.\nEl caso es que, en este punto, aún seguía pensando en una combinación de técnicas. Tenía pendiente hacer tests para ver hasta qué punto podía controlar totalmente los registros de scroll, pero entre que aquello había que hacerlo sí o sí en ensamblador, y que ni siquiera había creado mi primer hello world para la máquina en ese lenguaje, lo fui dejando un largo tiempo más.\nY así pasaron años sin ningún avance, hasta que llegaron los desencadenantes que comenté en mi primer post: mi despido y el hallazgo de ese código (Canyon Racer) que demostraba que sí era posible manipular un scroll parcial horizontal, aunque fuera en un contexto muy limitado.\nEn el siguiente post veremos cómo finalmente me lancé a programar, intentando en un principio solo calmar mi obsesión y ver si realmente era posible mi idea, pero terminando con una demo técnica de lo más resultona.\nRecursos mencionados:\nGame Boy Graphics \u0026amp; How To Code Them - NesHacker · PanDocs · Canyon Racer\n","date":"23 octubre 2025","externalUrl":null,"permalink":"/es/posts/gameboy-window-scroll/","section":"Posts","summary":"De cómo me complique la vida aun más","title":"Buscando una salida, la ventana, los sprites y el scroll","type":"posts"},{"content":"","date":"23 octubre 2025","externalUrl":null,"permalink":"/es/series/choco-charlie/","section":"Series","summary":"","title":"Choco Charlie","type":"series"},{"content":"","date":"23 octubre 2025","externalUrl":null,"permalink":"/es/tags/gameboy/","section":"Tags","summary":"","title":"Gameboy","type":"tags"},{"content":"","date":"23 octubre 2025","externalUrl":null,"permalink":"/es/tags/hardware/","section":"Tags","summary":"","title":"Hardware","type":"tags"},{"content":"","date":"23 octubre 2025","externalUrl":null,"permalink":"/es/tags/history/","section":"Tags","summary":"","title":"History","type":"tags"},{"content":"","date":"23 octubre 2025","externalUrl":null,"permalink":"/es/tags/indidev/","section":"Tags","summary":"","title":"Indidev","type":"tags"},{"content":"","date":"23 octubre 2025","externalUrl":null,"permalink":"/en/tags/indiedev/","section":"Tags","summary":"","title":"Indiedev","type":"tags"},{"content":"","date":"23 octubre 2025","externalUrl":null,"permalink":"/es/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"23 octubre 2025","externalUrl":null,"permalink":"/es/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"23 octubre 2025","externalUrl":null,"permalink":"/es/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"Entonces, a ver, lo que nos interesa: yo quiero mover bloques.\n¿La Game Boy puede mover tiles, no? ¿Cuántos a la vez?\nLa respuesta con trampa es: “todos”.\nComo ya hemos comentado, la Game Boy puede hacer scroll de su tilemap (background); de este modo, mover lo que se dice mover puede mover casi 4 veces todos los tiles que le caben por pantalla (todo su tilemap). Eso sí, esos tiles han tenido que ser cargados previamente en dicha parte de la memoria, y aquí reside la trampa: esta carga, aun siendo muy rápida para los estándares de la época (ya que no vuelve a recrear píxel por píxel, sino que va a buscar cada tile entero del tileset para copiarlo eficientemente), para los estándares actuales es bastante lenta.\nEsto de “bastante lenta” es, en efecto, relativo, pero hay que tener en cuenta que la memoria de video no puede ser manipulada todo el tiempo, sino solo en un periodo concreto del ciclo de renderizado de la pantalla (vblank o hblank).\nLa Game Boy tiene un ciclo de renderizado fijo de 60 frames por segundo; si en ese periodo no se han copiado todos los tiles necesarios, habrá que esperar otro frame entero para acabar la tarea.\nCiclo de renderizado de la PPU de Game Boy durante un frame. Fuente: The Ultimate Game Boy Talk (44:39)\nEsto se traduce, por ejemplo, en que la mayoría de los juegos que cargan nuevas zonas en el scroll, ya sea vertical, horizontal o ambos, utilizan algoritmos para cargar pequeñas partes del tilemap con nuevos tiles durante el corto periodo que dura el vblank, y así dar la ilusión de nuevos gráficos, limitando también la velocidad de scroll efectiva del juego.\nDe hecho, algo tan “sencillo” como lograr un scroll al pasar a una nueva zona, como en el Zelda: Link’s Awakening, no es trivial y se sirve de un pequeño tiempo de espera en cada transición que se disimula con efectos visuales.\nLa historia de cómo los prototipos de Nintendo y otras compañías consiguieron el milagro de llevar juegos “tipo Zelda” a la máquina es súper interesante; os recomiendo echarle un ojo. No sería hasta mucho más adelante que juegos como Donkey Kong Land consiguieran la proeza de hacer scroll bidireccional en tiempo real.\nEntonces, algo tan inocente como “quiero empujar cualquier cantidad de bloques en una cuadrícula a cualquier posición” se puede transformar rápidamente en una quimera.\nVamos afinando la pregunta: ¿de cuántos tiles nuevos estamos hablando? ¿Se requiere cambiar todo el tablero de juego a la vez?\nSi se está hablando de mover cualquier cantidad de tiles, aunque sea de una posición A a la adyacente B, tenemos un problema.\nVolvamos a repasar cómo funciona la Game Boy. (En realidad, va a ser la primera vez que voy a tratar de explicarlo \u0026ldquo;bien\u0026rdquo;.)\nLa Game Boy tiene una resolución de pantalla de 160x144 píxeles; esto equivale a 20x18 tiles.\nPara poder dar a los juegos con scroll el suficiente margen de tiempo para incluir nuevos contenidos, los ingenieros pensaron (y pensaron bien) que con un canvas (tilemap) en memoria de 32x32 tiles, algo así como un 1.5-1.8 del tamaño de la pantalla, sería suficiente.\nEjemplo de la parte visible del tilemap dadas unas posiciones determinadas del scroll SCX SCY. Fuente: Game Boy Graphics \u0026amp; How To Code Them 2:58 (NesHacker)\nEl tilemap puede rellenarse con tiles provenientes de otra zona de memoria de la PPU llamada tileset. Este actúa como una biblioteca de donde se obtienen los tiles que se dibujan en el background (tilemap).\nEsta biblioteca no es tampoco ilimitada y tiene espacio para unos 384 tiles, de los cuales, a efectos prácticos, se pueden usar unos 256 en un momento determinado.\nEsto también limita el margen de maniobra en este punto; si dispusiéramos de tiles “infinitos” con gráficos precalculados en distintas posiciones, podríamos intercambiar tiempo de procesado por memoria, algo muy común en algoritmos de rendimiento. Pero no nos adelantemos.\nComo mucho, y sin hacer nada más, en cada frame da tiempo a copiar unos 80 nuevos tiles del tileset al tilemap, pudiendo copiar incluso más si la copia está alineada en memoria, pero eso solo serviría en escenarios muy concretos.\nVolviendo a mi juego, eso resultaría en un movimiento de bloques bastante poco fluido por dos motivos:\nel primero es que los bloques se moverían en intervalos de 8 píxeles (1 tile) y, además, para cubrir la mayoría de los casos sin que el juego sufriera ralentizaciones, habría que establecer un loop de renderizado virtual de 30 frames por segundo que usara paquetes de renderizado reales de 2 frames para duplicar el número de tiles que podríamos copiar, unos 160.\nOtra posibilidad también muy válida sería atacar al tileset en vez del tilemap, o una combinación de ambas cosas.\nCuando intercambias un tile del tileset por otro, esto afecta automáticamente a todas las copias de ese tile en el tilemap.\nDe este modo, la idea sería aumentar la fluidez actualizando el tileset con una copia de cada uno de los bloques en una posición intermedia de empuje, ya sea acompañado de un hueco o de su bloque vecino en esa dirección (optimización con precálculo en memoria);\naun así, en la práctica, eso solo haría que el movimiento fuera más fluido, pero también mucho más lento.\nYa que la carga de gráficos en el tileset, a pesar de poder actualizar todos los tiles referenciados en el tilemap a la vez, es extremadamente lenta de por sí, pudiendo llegar solo a los 4 tiles por frame alineados en memoria.\nPor otro lado, tenemos los sprites, que no tienen todas estas limitaciones.\nSon pequeños objetos independientes de 8x8 o 8x16 píxeles (puedes escoger uno u otro modo, no los dos a la vez) o, dicho de otro modo, (1 tile o bien 2 tiles, uno encima del otro en vertical).\nEstos objetos pueden no estar alineados con ningún tile del background, es decir, moverse independientemente del mismo en posiciones entre tiles, sin necesidad de manipular la memoria del tileset;\ny en cualquier cantidad sin apenas impacto en el rendimiento, la PPU se encarga de todo usando una memoria reservada para ello, la OAM (Object Attribute Memory); y pudiendo copiar gráficos a ella de manera mucho más eficiente a través del OAM DMA.\nComo decía, la Game Boy está específicamente diseñada para permitir dar vida a estos objetos independientes.\nLa operación de volver a copiar todos los datos de los 40 sprites a la OAM usando DMA (Direct Memory Access) y, por lo tanto, modificar la posición de los mismos es muy rápida y se puede efectuar en un solo frame con mucho margen de tiempo. Fuente Game Boy Graphics \u0026amp; How To Code Them 5:58 (NesHacker)\nSi quisiera mover un solo bloque o incluso 40 bloques a la vez (el número máximo de sprites), ¿podría hacerlo usando sprites? ¿No sería eso suficiente para crear mi juego?\nImaginemos, para este caso, que los sprites son de 8x8 píxeles.\nPonemos todos los sprites en pantalla para crear mi juego en un tablero cuadrado, por ejemplo, de 5x5.\nEso crearía un tablero chiquitito de 40x40 píxeles, y con el resto de la pantalla, ¿qué hacemos? No mucho más, no nos quedan sprites; además, 5x5 parecen pocos bloques para mi juego.\nAlgunos juegos de puzle para Game Boy usan bloques pequeños de 1 tile, como el Tetris o el Dr. Mario, pero el diseño de esos juegos parte de la idea de tener una pequeña parte móvil interactiva (que usa sprites) y luego un tablero establecido dibujado en el tilemap.\nAdemás de la falta de atractivo visual, la solución de bloques pequeños no me permitiría ninguna flexibilidad en cuanto a mecánicas de juego; si necesitara algún sprite más para alguna animación, no lo iba a tener; en definitiva, muchos problemas y pocas ventajas.\nLa idea de juego que tenía en mi cabeza era algo más cercano a Yoshi’s Cookie o Panel de Pon (Tetris Attack).\nEn estos juegos se usan metatiles. Un metatile es un conjunto de tiles que representa una única estructura, ya sea un objeto/sprite o una parte reutilizable del fondo.\nTanto en Yoshi’s Cookie como en Panel de Pon se utilizan metatiles de 16x16 píxeles (2x2 tiles) para dar más detalle y mejor visibilidad al juego.\nEso implica que, ahora, para tener un tablero de 5x5, ni siquiera con todos los sprites por pantalla me iba a ir de rositas; necesitaría 4 veces más sprites, o con el modo de sprites de 8x16, 2 veces más sprites, y ya hemos dicho que con 5x5 las mecánicas de juego quedarían limitadas.\nYo quería mínimo un tablero de 7x7 bloques grandotes, bonitos y vistosos, que se movieran fluidamente en cualquier dirección y en cualquier cantidad.\nY lo quería ya, (Y una paella, también.)\nEn la siguiente entrada veremos cómo esa obstinación me llevó de visita por otras partes de la arquitectura de la Game Boy, intentando esquivar todas estas limitaciones y hacer mi juego posible de las maneras más rocambolescas, olvidando que estaba dejando de lado lo más importante en un desarrollo de software serio: ¡la simplicidad!\nRecursos mencionados:\nThe Ultimate Game Boy Talk - 33c3 · Game Boy Graphics \u0026amp; How To Code Them - NesHacker\n","date":"20 octubre 2025","externalUrl":null,"permalink":"/es/posts/arquitectura-de-gameboy/","section":"Posts","summary":"Comprendiendo la arquitectura de Game Boy","title":"Empujar bloques es... complicado","type":"posts"},{"content":"En términos de arquitectura, la Game Boy es una máquina mucho más avanzada que la Nintendo NES. A pesar de ser una consola portátil en algunos aspectos menos potente por estar centrada también en la eficiencia energética, muchas de las cosas aprendidas en NES se trasladaron perfeccionadas a Game Boy, manteniendo al mismo tiempo los mismos esquemas de desarrollo, todo ello de manera premeditada, entre otras cosas, para facilitar el trabajo a los desarrolladores que habían evolucionado de la mano de la arquitectura de NES para formar parte de la nueva era del videojuego moderno.\nAl contrario de otras máquinas anteriores más parecidas a los microordenadores, la arquitectura de gráficos de Game Boy contaba, como en NES, con su propia memoria de video reservada (llamada vram), totalmente enfocada en alojar tiles (paquetes gráficos de 8x8 píxeles). Bajo este tipo de esquema, la consola era capaz de crear juegos tan ricos y variados como Link\u0026rsquo;s Awakening o Kirby\u0026rsquo;s Dream Land con modos de scroll súper fluidos. Junto a ese fondo con scroll fino, la consola también tenía una parte reservada a los actores o sprites, representando al jugador, enemigos y demás elementos interactivos. E incluso un fondo alternativo pensado para albergar el HUD, facilitando así muchísimo el trabajo de los equipos de desarrollo.\nEl tileset constituye los bloques de construcción de los gráficos La ppu reordena los tiles en el tilemap para formar los fondos La ppu también puede usar su tileset para incluir sprites Además, la consola contaba con otra baza a su favor respecto a NES. Su baja resolución hacía que el número máximo de sprites por pantalla (40, 10 por linea), ligeramente menor que el de NES (64, 8 por linea), fuera comparativamente mucho mayor en términos de espacio en pantalla.\nTambién contaba con mejoras de calidad de vida, como la capacidad de tener un control mucho más fino del render de video horizontal, lo que hacía que trucos gráficos que requerían mucho trabajo en NES, como fondos con efecto parallax, fueran casi features que la flamante nueva portátil de Nintendo podía efectuar sin despeinarse.\nEn definitiva, la consola era como una NES portátil, con menos potencia bruta en algunos aspectos, pero totalmente optimizada para realizar el tipo de juegos que estaban de moda en la época. Es por eso que los programadores de Game Boy desde el principio consiguieron hacer que pareciera fácil lo que en realidad había sido difícil en los días iniciales de NES. Llegando hacia el final de la vida de la consola a crear auténticas obras de arte de ingeniería de 8 bits.\nCreo que fue eso lo que me llevó a pensar que mi idea de juego era posible; veía a juegos como Yoshie Cookie y Tetris Attack (o Panel de Pon) hacer cosas que parecían similares a las que yo quería hacer. Lo que no sabía es que esos juegos estaban llenos de trucos gráficos y aprovechaban la consola al 100% a pesar de parecer juegos de puzzles inofensivos, llevando algunas de las funcionalidades de la consola más allá de juegos que parecen mucho más ambiciosos, como los Pokémon o los Zelda.\nLos juegos de puzzles nunca han sido tan populares como tras el lanzamiento de Tetris para Game Boy en 1989-1990, algo que, a mi modo de ver, también pilló a Nintendo a contra pie. Llegando incluso a crear en muy poco tiempo la franquicia Doctor Mario como un intento de competir con la fiebre tetrominica, o al menos tratar de marcarse otro pelotazo a ese nivel.\nAl venir de máquinas mucho más antiguas y menos potentes, costó relativamente poco portear Tetris a la máquina, lo cual no quiere decir que Game Boy estuviera diseñada para este tipo de juegos.\nAun así, el mercado mandaba y la gente quería más puzzles para Game Boy; es por ello que podemos ver obras de ingeniería como las que he nombrado, que desafían en cierto modo la intención principal de la arquitectura de la máquina y, por otra parte, también están diseñados en torno a las limitaciones de esta con las lecciones aprendidas del mismo port de Tetris. Os dejo por aquí un maravilloso tutorial de cómo crear un juego de Tetris para Game Boy con GBDK de la mano de Larold’s Retro Gameyard con un diseño similar al que usaron en la época.\nTotal, que me había escogido un género difícil para desarrollar mi Homebrew, y por si fuera poco, la documentación y los ejemplos que hoy día puedes encontrar en internet, en su mayoría, se centran en juegos de esos géneros “fáciles”, rpgs o Action rpgs tipo Zelda o Pokémon, así como juegos de plataformas tipo Mario Land. Juegos para los que la plataforma fue diseñada en un principio, existiendo en la actualidad incluso motores centrados en facilitar mucho el desarrollo de este tipo de juegos, como Zgb o Gb Studio.\nEn este punto, un ingeniero sensato hubiera pensado algo así como: “esto no cabe aquí” y hubiera seguido con su vida, o al menos hubiera repensado su idea conforme a las limitaciones aprendidas, pero yo no soy un ingeniero sensato; para no ser ingeniero, no soy ni ingeniero.\nSeguidme en esta loca aventura en la siguiente entrada del blog donde trataremos de hacer mi juego posible en Game Boy una vez más.\nRecursos mencionados:\nLarold’s Retro Gameyard · ZGB Engine · GB Studio\n","date":"17 octubre 2025","externalUrl":null,"permalink":"/es/posts/los-graficos-en-gameboy/","section":"Posts","summary":"Hacer juegos tipo puzzle en Game Boy, es difícil","title":"Game Boy, la NES portátil perfecta","type":"posts"},{"content":"","date":"17 octubre 2025","externalUrl":null,"permalink":"/es/tags/lifehacks/","section":"Tags","summary":"","title":"Lifehacks","type":"tags"},{"content":"Siete años llevaba rondándome por la cabeza una idea para un juego de Game Boy: un juego de puzles en el que un personaje empujaría bloques libremente por la pantalla para formar figuras.\n¿Por qué nadie había hecho algo así? Era tan obvio para mí que eso iba a funcionar. En efecto, era un ingenuo, y lo sigo siendo; eso es lo que me ha traído hasta aquí. Ojalá siga siendo un ingenuo siempre.\nLa pregunta más obvia que uno puede hacerse al leer semejante simpleza es: ¿por qué me obsesioné tanto con esta idea? No era la primera vez que se me ocurría un juego; como toda persona creativa con ganas de hacer videojuegos, había confeccionado a lo largo de los años una lista interminable de conceptos sin realizar, de lo más variopintos, algunos incluso más sencillos y prometedores. ¿Qué tenía esta idea en particular para sobrevivir tanto tiempo y, de forma totalmente impensable, llegar a materializarse? Creo saber la respuesta, y la llamo con cierta ironía sinergia motivacional.\n¿Procrastinador profesional? Quizá esta idea te “sirva” 🙂 (en realidad no).\nDesde pequeño soñaba con hacer videojuegos, pero había otro sueño paralelo que se entrelazaba con el primero: poder crearlos para consolas retro. Mi primera consola fue una NES, con el combo Blue Shadow (Shadow of the Ninja en EE. UU.), Super Mario Bros. 3 y Mega Man 3. Tres obras maestras que dejaron a mi yo de cinco años completamente extasiado. A día de hoy, no me he recuperado.\nSuper Mario Bros. 3 Mega Man 3 Blue Shadow (Shadow of the Ninja) A día de hoy sigo estando enganchado al retro, sobretodo a la época de 8-16 bits, así fue como viendo juegos como Mr. Driller para Game Boy Color, me dije a mí mismo que mi idea tenía que ser posible en esa consola. Era perfecta para ella: un concepto simple, sin controles complejos, que encajaba de maravilla con la filosofía de la máquina. Soñaba con mezclar influencias de Bomberman, Mr. Driller, Tetris Attack e incluso Candy Crush, y aun así crear algo que se sintiera nuevo, fresco, casi inevitable. Esa mezcla absurda, unida a la estética directa y austera de la Game Boy, hacía volar mi imaginación.\nMr Driller Yoshie Cookies Tetris Attack Por alguna razón, estaba convencido de que el juego podía hacerse en la consola. Lo intuía. Y sin embargo cuanto más aprendía sobre su funcionamiento interno, más difícil parecía: un muro enorme se alzaba entre mi idea y yo, y eso, lejos de disuadirme, hacía el reto aun más atractivo.\nAhí es donde entra en juego la supuesta sinergia. Tengo un trastorno por hiperactividad bastante agudo; necesito una motivación colosal para avanzar en algo, incluso si me apasiona. Y aun así, siempre encuentro un argumento para no hacerlo. Con los años he aprendido a detectar oportunidades como esta, esas en las que puedo hackearme a mí mismo y usar mis propias distracciones como combustible. Era una ocasión de oro: podía aprovechar toda esa energía para aprender más sobre la plataforma, explorar la comunidad de desarrollo de Game Boy y empaparme de su ecosistema. Mientras tanto, podía seguir procrastinando. No hacer el juego todavía. Porque no estaba preparado, ¿verdad?\nHablé con varias personas de la comunidad y les expliqué torpemente mi idea. Me decían que era casi imposible, que me olvidara y empezara por algo más sencillo. Aquello fue, por supuesto, irresistible. ¿Que no se puede? Agárrame la birra.\nPero tenían razón. Empecé a probar distintos motores: GBDK, ZGB Engine (por entonces aún no existía GB Studio). Pronto comprendí que ninguno estaba pensado para lo que yo quería. No voy a entrar en detalles técnicos de momento, pero en mi cabeza el juego movía montones de piezas sin restricción alguna, empujándose unas a otras y de manera fluida.\nCasi nada. Si quería sacarlo adelante, tendría que bajar a nivel de ensamblador. ¡Qué pereza, por Dios! No tocaba ensamblador desde la universidad y, aunque técnicamente me veía capaz de retomarlo, mi capacidad de procrastinación es infinita. Así que volví a lo de siempre: leer más documentación, ver más ejemplos, ver más vídeos, pensar estrategias para el motor de juego… y no escribir ni una sola línea de código.\n¿Y sabes qué? El método al final dio sus frutos, al menos si ignoras el pequeño detalle de los siete años que tardé en empezar. Nadie dijo que fuera rápido 😂. Pero siendo sincero, no es que el método funcione con el tiempo: es que, en realidad, no funciona. La clave de mi “sinergia motivacional” (también conocida como evitación sistemática) es que nunca llegas a ejecutar la idea que te dio la motivación inicial. Y, sin embargo, ese bucle interminable acabó rompiéndose. No por mí, sino por la vida.\nDurante ese tiempo, mi carrera como full stack developer iba viento en popa, impulsada por la burbuja de las aplicaciones multiplataforma. Proyecto tras proyecto, sueldo tras sueldo, me fui hundiendo en una especie de workaholismo que no me dejaba tiempo para nada más.\nHasta que, a principios de este año (2025, para quien lea esto en plena era de la IA —lo cual dudo bastante—), la burbuja estalló. Y con ello, mi empleo.\nCasi al mismo tiempo ocurrió algo que, visto en retrospectiva, fue providencial. Un día, en una de mis enésimas sesiones de investigación rutinaria sobre cómo podría hacer realidad mi juego, me topé con una demo llamada Canyon Racer. Estaba hecha en GBDK ¡yupi, sin ensamblador ! Lo importante es que esa demo tenía la clave que haría realidad mis fantasías: cómo variar la velocidad del scroll a mitad de scanline. ¿Por qué era tan importante esto? Lo explicaré en detalle en posts posteriores, pero resumiendo, el caso es que tras tantos años de rumiar soluciones había llegado a la conclusión de que ese truco gráfico era lo único que podía hacer posible mi juego imposible.\nY eso tenía que ser la señal que llevaba años esperando. Ya no me quedaban excusas. Estaba obligado a probar suerte.\nFue así como comenzó mi periplo. Pero antes de hablar del proceso de desarrollo en sí, me gustaría dedicar la siguiente entrada a explicar, a mi manera, las limitaciones gráficas de la Game Boy. No será un texto técnico al uso, sino una explicación personal de cómo veo yo esa pequeña máquina maravillosa.\nY si este texto sirve para que alguien más se lance a la piscina, con suerte más rápido de lo que lo hice yo, me daré por satisfecho.\nRecursos mencionados:\nAwesome Game Boy · Gbdev Community · GBDK 2020 · RGBDS · ZGB Engine · GB Studio · Canyon Racer\n","date":"17 octubre 2025","externalUrl":null,"permalink":"/es/posts/los-inicios-el-proyecto-que-nunca-empieza/","section":"Posts","summary":"De cómo tarde 7 años en empezar mi juego de Game Boy","title":"Los inicios: El proyecto que nunca empieza","type":"posts"},{"content":"","date":"17 octubre 2025","externalUrl":null,"permalink":"/es/tags/offtopic/","section":"Tags","summary":"","title":"Offtopic","type":"tags"},{"content":"Trabajo en Choco Charlie y otros proyectos de desarrollo indie. Estoy dispuesto a compartir mis pequeños conocimientos de desarrollo retro con cualquiera que esté interesado. ¡No dudes en contactarme si quieres saber más!\n","date":"17 octubre 2025","externalUrl":null,"permalink":"/es/","section":"TripleC Blog","summary":"","title":"TripleC Blog","type":"page"},{"content":"","externalUrl":null,"permalink":"/es/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/es/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]