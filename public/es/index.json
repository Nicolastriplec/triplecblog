


[{"content":"Lo de mover sprites resultaba prometedor, pero de momento no funcionaba; necesitaba reducir el uso de sprites de alg√∫n modo. Es entonces cuando, leyendo m√°s sobre la arquitectura de Game Boy, me top√© con algo prometedor, algo que los ingenieros hab√≠an dejado all√≠ para salvar mi vida (en realidad, no): la ventana, un segundo tilemap alternativo.\nLa ventana parec√≠a todo lo que hab√≠a podido so√±ar. ¬øOtra capa de gr√°ficos que se mueve independientemente de los sprites y el fondo? ¬øY encima se puede colocar sobre la otra? De este modo podr√≠a empujar una parte de la pantalla independientemente del resto. Solo ten√≠a que poner la ventana estrat√©gicamente en una parte de mi tablero y, entre el scroll del fondo y los sprites‚Ä¶ Malo ser√° que no consiga moverlo todo por separado arbitrariamente.\nPero a medida que empezaba a aprender m√°s sobre la ventana, me di cuenta de que esto no ser√≠a tan f√°cil. La ventana tiene dos limitaciones serias: la primera es que realmente no es una capa como tal; no tiene transparencias ni se puede elegir el orden en el que se dibuja ‚Äîsiempre va a tener prioridad respecto al background‚Äî; la segunda es que tampoco se puede colocar en cualquier lugar de la pantalla.\nLos juegos de Game Boy sol√≠an usar la ventana para el HUD y men√∫s de pausa. Fuente: Game Boy Graphics \u0026amp; How To Code Them 2:17 (NesHacker)\nLa ventana realmente sobrescribe la parte de la pantalla donde est√° activa, y esa parte no puede ser cualquier parte: tiene que ser todo el espacio desde una cierta posici√≥n X,Y hasta el final de la pantalla de la Game Boy. Esto hace imposible, a efectos pr√°cticos, colocarla cubriendo solo la parte izquierda de la pantalla; sin embargo, manipulando los registros a medio frame, s√≠ es posible hacer que cubra parcialmente regiones en sentido vertical, es decir, mostrarla solo en la parte superior o dejar un hueco entre la parte superior y la inferior.\nTomando todas estas limitaciones en cuenta, empec√© a hacer experimentos (mentales) para ver c√≥mo pod√≠a cubrir todos los casos de empuje de bloques. Un consejo: no hag√°is esto y mejor poneros a programar. Vais a llegar a una conclusi√≥n mucho m√°s r√°pida.\nPero siguiendo con mi delirio, empec√© a imaginar corner cases de lo m√°s problem√°ticos. Por ejemplo: ¬øqu√© pasar√≠a si solo quisiera mover los bloques de la parte central del tablero, pero no los de los extremos en sentido horizontal? Bueno, en ese caso los sprites podr√≠an volver al rescate. Pero ¬øY si solo quisiera mover uno o dos bloques? Entonces habr√≠a que hacer lo contrario, sprites m√≥viles y fondo est√°tico, claro, pero entonces‚Ä¶\nAqu√≠ me empezaba a explotar la cabeza. Si bien ser√≠a t√©cnicamente posible cubrir la mayor√≠a de los casos usando estrat√©gicamente los tres recursos (Sprites, Background y Ventana), nadie me aseguraba que no hubiera alg√∫n corner case imposible de cubrir. Y en el mejor de los casos, acabar√≠a con un motor gr√°fico hecho a base de parches y excepciones imposible de mantener.\nNo‚Ä¶ La cosa ten√≠a que ser m√°s sencilla, m√°s consistente; necesitaba coherencia interna. Una vez m√°s, la m√°quina no parec√≠a estar hecha para mi juego; me sent√≠a como un ni√±o tratando de construir una Game Boy con piezas de LEGO.\n¬øEstaba pidiendo demasiado? Quiz√°s s√≠, pero hab√≠a una idea que me hab√≠a estado rondando por la cabeza desde hac√≠a tiempo; ten√≠a un plan: el scroll parcial al rescate.\nHay que detenerse un momento aqu√≠ para explicar otra vez c√≥mo funciona el modo de renderizado de la PPU de Game Boy. Los gr√°ficos en Game Boy se dibujan l√≠nea por l√≠nea de p√≠xeles, de arriba a abajo, tal como lo har√≠a una CRT de la √©poca. Esto se hace, una vez m√°s, para mantener el mismo esquema de desarrollo que en NES, imitando tambi√©n el tiempo de espera entre l√≠neas llamado hblank y el tiempo de espera tras el dibujado total de la pantalla, que ya hemos mencionado en el anterior post: vblank.\nEn cada uno de estos momentos, la consola lanza una interrupci√≥n para indicar que est√° procediendo a cada una de estas fases, tanto en hblank como en vblank. Esto es √∫til porque en esos periodos es cuando es seguro copiar nuevos tiles a la memoria de video de la consola, ya sea al tilemap o al tileset. Pero tambi√©n se puede usar para crear efectos que generen cambios a mitad de pantalla, como cambiar la velocidad de scroll en una determinada scanline para generar efectos de profundidad o parallax.\nEjemplo: en BATMAN: Return Of The Joker para NES se usan estas t√©cnicas midframe para crear un efecto parallax imponente\nEl caso es que mi juego, donde se mueven filas o columnas de bloques, se ver√≠a ampliamente beneficiado por un efecto as√≠, pudiendo usar simplemente scroll en unas cuantas l√≠neas en vez de tener que copiar nuevos tiles al background cada vez que el usuario arrastrara una columna. El problema es que eso solo iba a servir para filas de bloques y no para columnas, porque la Game Boy no tiene modo de generar interrupciones en posiciones verticales arbitrarias en cada frame.\nAun as√≠, en teor√≠a ser√≠a posible sincronizarse con el tiempo de dibujado de cada una de las l√≠neas para cambiar los valores del scroll en una posici√≥n determinada en el eje horizontal. La documentaci√≥n disponible hoy en d√≠a menciona de manera muy resumida esta posibilidad, pero deja muy claro que intentar manipular gr√°ficos durante el dibujado de cada l√≠nea es muy peligroso.\nLos PanDocs de Game Boy ofrecen adem√°s informaci√≥n detallada sobre el timing de la PPU e incluso contienen informaci√≥n de c√≥mo var√≠a el timing. Porque s√≠, amigos, aqu√≠ radica el problema: el tiempo de renderizado de cada l√≠nea por la PPU es variable, y ese es uno de los motivos principales de su dificultad a la hora de sincronizarse con √©l.\nMe cost√≥ alg√∫n tiempo comprender que los registros que controlan el scroll no formaban parte de esta restricci√≥n; aun as√≠, tambi√©n se insist√≠a en que intentar manipular esos registros en ese punto era tremendamente complicado e incluso inestable. M√°s adelante comprender√≠a el porqu√©, pero no nos adelantemos.\nEl caso es que, en este punto, a√∫n segu√≠a pensando en una combinaci√≥n de t√©cnicas. Ten√≠a pendiente hacer tests para ver hasta qu√© punto pod√≠a controlar totalmente los registros de scroll, pero entre que aquello hab√≠a que hacerlo s√≠ o s√≠ en ensamblador, y que ni siquiera hab√≠a creado mi primer hello world para la m√°quina en ese lenguaje, lo fui dejando un largo tiempo m√°s.\nY as√≠ pasaron a√±os sin ning√∫n avance, hasta que llegaron los desencadenantes que coment√© en mi primer post: mi despido y el hallazgo de ese c√≥digo (Canyon Racer) que demostraba que s√≠ era posible manipular un scroll parcial horizontal, aunque fuera en un contexto muy limitado.\nEn el siguiente post veremos c√≥mo finalmente me lanc√© a programar, intentando en un principio solo calmar mi obsesi√≥n y ver si realmente era posible mi idea, pero terminando con una demo t√©cnica de lo m√°s resultona.\nRecursos mencionados:\nGame Boy Graphics \u0026amp; How To Code Them - NesHacker ¬∑ PanDocs ¬∑ Canyon Racer\n","date":"23 octubre 2025","externalUrl":null,"permalink":"/es/posts/gameboy-window-scroll/","section":"Posts","summary":"De c√≥mo me complique la vida aun m√°s","title":"Buscando una salida, la ventana, los sprites y el scroll","type":"posts"},{"content":"","date":"23 octubre 2025","externalUrl":null,"permalink":"/es/series/choco-charlie/","section":"Series","summary":"","title":"Choco Charlie","type":"series"},{"content":"","date":"23 octubre 2025","externalUrl":null,"permalink":"/es/tags/gameboy/","section":"Tags","summary":"","title":"Gameboy","type":"tags"},{"content":"","date":"23 octubre 2025","externalUrl":null,"permalink":"/es/tags/hardware/","section":"Tags","summary":"","title":"Hardware","type":"tags"},{"content":"","date":"23 octubre 2025","externalUrl":null,"permalink":"/es/tags/history/","section":"Tags","summary":"","title":"History","type":"tags"},{"content":"","date":"23 octubre 2025","externalUrl":null,"permalink":"/es/tags/indidev/","section":"Tags","summary":"","title":"Indidev","type":"tags"},{"content":"","date":"23 octubre 2025","externalUrl":null,"permalink":"/en/tags/indiedev/","section":"Tags","summary":"","title":"Indiedev","type":"tags"},{"content":"","date":"23 octubre 2025","externalUrl":null,"permalink":"/es/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"23 octubre 2025","externalUrl":null,"permalink":"/es/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"23 octubre 2025","externalUrl":null,"permalink":"/es/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"Entonces, a ver, lo que nos interesa: yo quiero mover bloques.\n¬øLa Game Boy puede mover tiles, no? ¬øCu√°ntos a la vez?\nLa respuesta con trampa es: ‚Äútodos‚Äù.\nComo ya hemos comentado, la Game Boy puede hacer scroll de su tilemap (background); de este modo, mover lo que se dice mover puede mover casi 4 veces todos los tiles que le caben por pantalla (todo su tilemap). Eso s√≠, esos tiles han tenido que ser cargados previamente en dicha parte de la memoria, y aqu√≠ reside la trampa: esta carga, aun siendo muy r√°pida para los est√°ndares de la √©poca (ya que no vuelve a recrear p√≠xel por p√≠xel, sino que va a buscar cada tile entero del tileset para copiarlo eficientemente), para los est√°ndares actuales es bastante lenta.\nEsto de ‚Äúbastante lenta‚Äù es, en efecto, relativo, pero hay que tener en cuenta que la memoria de video no puede ser manipulada todo el tiempo, sino solo en un periodo concreto del ciclo de renderizado de la pantalla (vblank o hblank).\nLa Game Boy tiene un ciclo de renderizado fijo de 60 frames por segundo; si en ese periodo no se han copiado todos los tiles necesarios, habr√° que esperar otro frame entero para acabar la tarea.\nCiclo de renderizado de la PPU de Game Boy durante un frame. Fuente: The Ultimate Game Boy Talk (44:39)\nEsto se traduce, por ejemplo, en que la mayor√≠a de los juegos que cargan nuevas zonas en el scroll, ya sea vertical, horizontal o ambos, utilizan algoritmos para cargar peque√±as partes del tilemap con nuevos tiles durante el corto periodo que dura el vblank, y as√≠ dar la ilusi√≥n de nuevos gr√°ficos, limitando tambi√©n la velocidad de scroll efectiva del juego.\nDe hecho, algo tan ‚Äúsencillo‚Äù como lograr un scroll al pasar a una nueva zona, como en el Zelda: Link‚Äôs Awakening, no es trivial y se sirve de un peque√±o tiempo de espera en cada transici√≥n que se disimula con efectos visuales.\nLa historia de c√≥mo los prototipos de Nintendo y otras compa√±√≠as consiguieron el milagro de llevar juegos ‚Äútipo Zelda‚Äù a la m√°quina es s√∫per interesante; os recomiendo echarle un ojo. No ser√≠a hasta mucho m√°s adelante que juegos como Donkey Kong Land consiguieran la proeza de hacer scroll bidireccional en tiempo real.\nEntonces, algo tan inocente como ‚Äúquiero empujar cualquier cantidad de bloques en una cuadr√≠cula a cualquier posici√≥n‚Äù se puede transformar r√°pidamente en una quimera.\nVamos afinando la pregunta: ¬øde cu√°ntos tiles nuevos estamos hablando? ¬øSe requiere cambiar todo el tablero de juego a la vez?\nSi se est√° hablando de mover cualquier cantidad de tiles, aunque sea de una posici√≥n A a la adyacente B, tenemos un problema.\nVolvamos a repasar c√≥mo funciona la Game Boy. (En realidad, va a ser la primera vez que voy a tratar de explicarlo \u0026ldquo;bien\u0026rdquo;.)\nLa Game Boy tiene una resoluci√≥n de pantalla de 160x144 p√≠xeles; esto equivale a 20x18 tiles.\nPara poder dar a los juegos con scroll el suficiente margen de tiempo para incluir nuevos contenidos, los ingenieros pensaron (y pensaron bien) que con un canvas (tilemap) en memoria de 32x32 tiles, algo as√≠ como un 1.5-1.8 del tama√±o de la pantalla, ser√≠a suficiente.\nEjemplo de la parte visible del tilemap dadas unas posiciones determinadas del scroll SCX SCY. Fuente: Game Boy Graphics \u0026amp; How To Code Them 2:58 (NesHacker)\nEl tilemap puede rellenarse con tiles provenientes de otra zona de memoria de la PPU llamada tileset. Este act√∫a como una biblioteca de donde se obtienen los tiles que se dibujan en el background (tilemap).\nEsta biblioteca no es tampoco ilimitada y tiene espacio para unos 384 tiles, de los cuales, a efectos pr√°cticos, se pueden usar unos 256 en un momento determinado.\nEsto tambi√©n limita el margen de maniobra en este punto; si dispusi√©ramos de tiles ‚Äúinfinitos‚Äù con gr√°ficos precalculados en distintas posiciones, podr√≠amos intercambiar tiempo de procesado por memoria, algo muy com√∫n en algoritmos de rendimiento. Pero no nos adelantemos.\nComo mucho, y sin hacer nada m√°s, en cada frame da tiempo a copiar unos 80 nuevos tiles del tileset al tilemap, pudiendo copiar incluso m√°s si la copia est√° alineada en memoria, pero eso solo servir√≠a en escenarios muy concretos.\nVolviendo a mi juego, eso resultar√≠a en un movimiento de bloques bastante poco fluido por dos motivos:\nel primero es que los bloques se mover√≠an en intervalos de 8 p√≠xeles (1 tile) y, adem√°s, para cubrir la mayor√≠a de los casos sin que el juego sufriera ralentizaciones, habr√≠a que establecer un loop de renderizado virtual de 30 frames por segundo que usara paquetes de renderizado reales de 2 frames para duplicar el n√∫mero de tiles que podr√≠amos copiar, unos 160.\nOtra posibilidad tambi√©n muy v√°lida ser√≠a atacar al tileset en vez del tilemap, o una combinaci√≥n de ambas cosas.\nCuando intercambias un tile del tileset por otro, esto afecta autom√°ticamente a todas las copias de ese tile en el tilemap.\nDe este modo, la idea ser√≠a aumentar la fluidez actualizando el tileset con una copia de cada uno de los bloques en una posici√≥n intermedia de empuje, ya sea acompa√±ado de un hueco o de su bloque vecino en esa direcci√≥n (optimizaci√≥n con prec√°lculo en memoria);\naun as√≠, en la pr√°ctica, eso solo har√≠a que el movimiento fuera m√°s fluido, pero tambi√©n mucho m√°s lento.\nYa que la carga de gr√°ficos en el tileset, a pesar de poder actualizar todos los tiles referenciados en el tilemap a la vez, es extremadamente lenta de por s√≠, pudiendo llegar solo a los 4 tiles por frame alineados en memoria.\nPor otro lado, tenemos los sprites, que no tienen todas estas limitaciones.\nSon peque√±os objetos independientes de 8x8 o 8x16 p√≠xeles (puedes escoger uno u otro modo, no los dos a la vez) o, dicho de otro modo, (1 tile o bien 2 tiles, uno encima del otro en vertical).\nEstos objetos pueden no estar alineados con ning√∫n tile del background, es decir, moverse independientemente del mismo en posiciones entre tiles, sin necesidad de manipular la memoria del tileset;\ny en cualquier cantidad sin apenas impacto en el rendimiento, la PPU se encarga de todo usando una memoria reservada para ello, la OAM (Object Attribute Memory); y pudiendo copiar gr√°ficos a ella de manera mucho m√°s eficiente a trav√©s del OAM DMA.\nComo dec√≠a, la Game Boy est√° espec√≠ficamente dise√±ada para permitir dar vida a estos objetos independientes.\nLa operaci√≥n de volver a copiar todos los datos de los 40 sprites a la OAM usando DMA (Direct Memory Access) y, por lo tanto, modificar la posici√≥n de los mismos es muy r√°pida y se puede efectuar en un solo frame con mucho margen de tiempo. Fuente Game Boy Graphics \u0026amp; How To Code Them 5:58 (NesHacker)\nSi quisiera mover un solo bloque o incluso 40 bloques a la vez (el n√∫mero m√°ximo de sprites), ¬øpodr√≠a hacerlo usando sprites? ¬øNo ser√≠a eso suficiente para crear mi juego?\nImaginemos, para este caso, que los sprites son de 8x8 p√≠xeles.\nPonemos todos los sprites en pantalla para crear mi juego en un tablero cuadrado, por ejemplo, de 5x5.\nEso crear√≠a un tablero chiquitito de 40x40 p√≠xeles, y con el resto de la pantalla, ¬øqu√© hacemos? No mucho m√°s, no nos quedan sprites; adem√°s, 5x5 parecen pocos bloques para mi juego.\nAlgunos juegos de puzle para Game Boy usan bloques peque√±os de 1 tile, como el Tetris o el Dr. Mario, pero el dise√±o de esos juegos parte de la idea de tener una peque√±a parte m√≥vil interactiva (que usa sprites) y luego un tablero establecido dibujado en el tilemap.\nAdem√°s de la falta de atractivo visual, la soluci√≥n de bloques peque√±os no me permitir√≠a ninguna flexibilidad en cuanto a mec√°nicas de juego; si necesitara alg√∫n sprite m√°s para alguna animaci√≥n, no lo iba a tener; en definitiva, muchos problemas y pocas ventajas.\nLa idea de juego que ten√≠a en mi cabeza era algo m√°s cercano a Yoshi‚Äôs Cookie o Panel de Pon (Tetris Attack).\nEn estos juegos se usan metatiles. Un metatile es un conjunto de tiles que representa una √∫nica estructura, ya sea un objeto/sprite o una parte reutilizable del fondo.\nTanto en Yoshi‚Äôs Cookie como en Panel de Pon se utilizan metatiles de 16x16 p√≠xeles (2x2 tiles) para dar m√°s detalle y mejor visibilidad al juego.\nEso implica que, ahora, para tener un tablero de 5x5, ni siquiera con todos los sprites por pantalla me iba a ir de rositas; necesitar√≠a 4 veces m√°s sprites, o con el modo de sprites de 8x16, 2 veces m√°s sprites, y ya hemos dicho que con 5x5 las mec√°nicas de juego quedar√≠an limitadas.\nYo quer√≠a m√≠nimo un tablero de 7x7 bloques grandotes, bonitos y vistosos, que se movieran fluidamente en cualquier direcci√≥n y en cualquier cantidad.\nY lo quer√≠a ya, (Y una paella, tambi√©n.)\nEn la siguiente entrada veremos c√≥mo esa obstinaci√≥n me llev√≥ de visita por otras partes de la arquitectura de la Game Boy, intentando esquivar todas estas limitaciones y hacer mi juego posible de las maneras m√°s rocambolescas, olvidando que estaba dejando de lado lo m√°s importante en un desarrollo de software serio: ¬°la simplicidad!\nRecursos mencionados:\nThe Ultimate Game Boy Talk - 33c3 ¬∑ Game Boy Graphics \u0026amp; How To Code Them - NesHacker\n","date":"20 octubre 2025","externalUrl":null,"permalink":"/es/posts/arquitectura-de-gameboy/","section":"Posts","summary":"Comprendiendo la arquitectura de Game Boy","title":"Empujar bloques es... complicado","type":"posts"},{"content":"En t√©rminos de arquitectura, la Game Boy es una m√°quina mucho m√°s avanzada que la Nintendo NES. A pesar de ser una consola port√°til en algunos aspectos menos potente por estar centrada tambi√©n en la eficiencia energ√©tica, muchas de las cosas aprendidas en NES se trasladaron perfeccionadas a Game Boy, manteniendo al mismo tiempo los mismos esquemas de desarrollo, todo ello de manera premeditada, entre otras cosas, para facilitar el trabajo a los desarrolladores que hab√≠an evolucionado de la mano de la arquitectura de NES para formar parte de la nueva era del videojuego moderno.\nAl contrario de otras m√°quinas anteriores m√°s parecidas a los microordenadores, la arquitectura de gr√°ficos de Game Boy contaba, como en NES, con su propia memoria de video reservada (llamada vram), totalmente enfocada en alojar tiles (paquetes gr√°ficos de 8x8 p√≠xeles). Bajo este tipo de esquema, la consola era capaz de crear juegos tan ricos y variados como Link\u0026rsquo;s Awakening o Kirby\u0026rsquo;s Dream Land con modos de scroll s√∫per fluidos. Junto a ese fondo con scroll fino, la consola tambi√©n ten√≠a una parte reservada a los actores o sprites, representando al jugador, enemigos y dem√°s elementos interactivos. E incluso un fondo alternativo pensado para albergar el HUD, facilitando as√≠ much√≠simo el trabajo de los equipos de desarrollo.\nEl tileset constituye los bloques de construcci√≥n de los gr√°ficos La ppu reordena los tiles en el tilemap para formar los fondos La ppu tambi√©n puede usar su tileset para incluir sprites Adem√°s, la consola contaba con otra baza a su favor respecto a NES. Su baja resoluci√≥n hac√≠a que el n√∫mero m√°ximo de sprites por pantalla (40, 10 por linea), ligeramente menor que el de NES (64, 8 por linea), fuera comparativamente mucho mayor en t√©rminos de espacio en pantalla.\nTambi√©n contaba con mejoras de calidad de vida, como la capacidad de tener un control mucho m√°s fino del render de video horizontal, lo que hac√≠a que trucos gr√°ficos que requer√≠an mucho trabajo en NES, como fondos con efecto parallax, fueran casi features que la flamante nueva port√°til de Nintendo pod√≠a efectuar sin despeinarse.\nEn definitiva, la consola era como una NES port√°til, con menos potencia bruta en algunos aspectos, pero totalmente optimizada para realizar el tipo de juegos que estaban de moda en la √©poca. Es por eso que los programadores de Game Boy desde el principio consiguieron hacer que pareciera f√°cil lo que en realidad hab√≠a sido dif√≠cil en los d√≠as iniciales de NES. Llegando hacia el final de la vida de la consola a crear aut√©nticas obras de arte de ingenier√≠a de 8 bits.\nCreo que fue eso lo que me llev√≥ a pensar que mi idea de juego era posible; ve√≠a a juegos como Yoshie Cookie y Tetris Attack (o Panel de Pon) hacer cosas que parec√≠an similares a las que yo quer√≠a hacer. Lo que no sab√≠a es que esos juegos estaban llenos de trucos gr√°ficos y aprovechaban la consola al 100% a pesar de parecer juegos de puzzles inofensivos, llevando algunas de las funcionalidades de la consola m√°s all√° de juegos que parecen mucho m√°s ambiciosos, como los Pok√©mon o los Zelda.\nLos juegos de puzzles nunca han sido tan populares como tras el lanzamiento de Tetris para Game Boy en 1989-1990, algo que, a mi modo de ver, tambi√©n pill√≥ a Nintendo a contra pie. Llegando incluso a crear en muy poco tiempo la franquicia Doctor Mario como un intento de competir con la fiebre tetrominica, o al menos tratar de marcarse otro pelotazo a ese nivel.\nAl venir de m√°quinas mucho m√°s antiguas y menos potentes, cost√≥ relativamente poco portear Tetris a la m√°quina, lo cual no quiere decir que Game Boy estuviera dise√±ada para este tipo de juegos.\nAun as√≠, el mercado mandaba y la gente quer√≠a m√°s puzzles para Game Boy; es por ello que podemos ver obras de ingenier√≠a como las que he nombrado, que desaf√≠an en cierto modo la intenci√≥n principal de la arquitectura de la m√°quina y, por otra parte, tambi√©n est√°n dise√±ados en torno a las limitaciones de esta con las lecciones aprendidas del mismo port de Tetris. Os dejo por aqu√≠ un maravilloso tutorial de c√≥mo crear un juego de Tetris para Game Boy con GBDK de la mano de Larold‚Äôs Retro Gameyard con un dise√±o similar al que usaron en la √©poca.\nTotal, que me hab√≠a escogido un g√©nero dif√≠cil para desarrollar mi Homebrew, y por si fuera poco, la documentaci√≥n y los ejemplos que hoy d√≠a puedes encontrar en internet, en su mayor√≠a, se centran en juegos de esos g√©neros ‚Äúf√°ciles‚Äù, rpgs o Action rpgs tipo Zelda o Pok√©mon, as√≠ como juegos de plataformas tipo Mario Land. Juegos para los que la plataforma fue dise√±ada en un principio, existiendo en la actualidad incluso motores centrados en facilitar mucho el desarrollo de este tipo de juegos, como Zgb o Gb Studio.\nEn este punto, un ingeniero sensato hubiera pensado algo as√≠ como: ‚Äúesto no cabe aqu√≠‚Äù y hubiera seguido con su vida, o al menos hubiera repensado su idea conforme a las limitaciones aprendidas, pero yo no soy un ingeniero sensato; para no ser ingeniero, no soy ni ingeniero.\nSeguidme en esta loca aventura en la siguiente entrada del blog donde trataremos de hacer mi juego posible en Game Boy una vez m√°s.\nRecursos mencionados:\nLarold‚Äôs Retro Gameyard ¬∑ ZGB Engine ¬∑ GB Studio\n","date":"17 octubre 2025","externalUrl":null,"permalink":"/es/posts/los-graficos-en-gameboy/","section":"Posts","summary":"Hacer juegos tipo puzzle en Game Boy, es dif√≠cil","title":"Game Boy, la NES port√°til perfecta","type":"posts"},{"content":"","date":"17 octubre 2025","externalUrl":null,"permalink":"/es/tags/lifehacks/","section":"Tags","summary":"","title":"Lifehacks","type":"tags"},{"content":"Siete a√±os llevaba rond√°ndome por la cabeza una idea para un juego de Game Boy: un juego de puzles en el que un personaje empujar√≠a bloques libremente por la pantalla para formar figuras.\n¬øPor qu√© nadie hab√≠a hecho algo as√≠? Era tan obvio para m√≠ que eso iba a funcionar. En efecto, era un ingenuo, y lo sigo siendo; eso es lo que me ha tra√≠do hasta aqu√≠. Ojal√° siga siendo un ingenuo siempre.\nLa pregunta m√°s obvia que uno puede hacerse al leer semejante simpleza es: ¬øpor qu√© me obsesion√© tanto con esta idea? No era la primera vez que se me ocurr√≠a un juego; como toda persona creativa con ganas de hacer videojuegos, hab√≠a confeccionado a lo largo de los a√±os una lista interminable de conceptos sin realizar, de lo m√°s variopintos, algunos incluso m√°s sencillos y prometedores. ¬øQu√© ten√≠a esta idea en particular para sobrevivir tanto tiempo y, de forma totalmente impensable, llegar a materializarse? Creo saber la respuesta, y la llamo con cierta iron√≠a sinergia motivacional.\n¬øProcrastinador profesional? Quiz√° esta idea te ‚Äúsirva‚Äù üôÇ (en realidad no).\nDesde peque√±o so√±aba con hacer videojuegos, pero hab√≠a otro sue√±o paralelo que se entrelazaba con el primero: poder crearlos para consolas retro. Mi primera consola fue una NES, con el combo Blue Shadow (Shadow of the Ninja en EE. UU.), Super Mario Bros. 3 y Mega Man 3. Tres obras maestras que dejaron a mi yo de cinco a√±os completamente extasiado. A d√≠a de hoy, no me he recuperado.\nSuper Mario Bros. 3 Mega Man 3 Blue Shadow (Shadow of the Ninja) A d√≠a de hoy sigo estando enganchado al retro, sobretodo a la √©poca de 8-16 bits, as√≠ fue como viendo juegos como Mr. Driller para Game Boy Color, me dije a m√≠ mismo que mi idea ten√≠a que ser posible en esa consola. Era perfecta para ella: un concepto simple, sin controles complejos, que encajaba de maravilla con la filosof√≠a de la m√°quina. So√±aba con mezclar influencias de Bomberman, Mr. Driller, Tetris Attack e incluso Candy Crush, y aun as√≠ crear algo que se sintiera nuevo, fresco, casi inevitable. Esa mezcla absurda, unida a la est√©tica directa y austera de la Game Boy, hac√≠a volar mi imaginaci√≥n.\nMr Driller Yoshie Cookies Tetris Attack Por alguna raz√≥n, estaba convencido de que el juego pod√≠a hacerse en la consola. Lo intu√≠a. Y sin embargo cuanto m√°s aprend√≠a sobre su funcionamiento interno, m√°s dif√≠cil parec√≠a: un muro enorme se alzaba entre mi idea y yo, y eso, lejos de disuadirme, hac√≠a el reto aun m√°s atractivo.\nAh√≠ es donde entra en juego la supuesta sinergia. Tengo un trastorno por hiperactividad bastante agudo; necesito una motivaci√≥n colosal para avanzar en algo, incluso si me apasiona. Y aun as√≠, siempre encuentro un argumento para no hacerlo. Con los a√±os he aprendido a detectar oportunidades como esta, esas en las que puedo hackearme a m√≠ mismo y usar mis propias distracciones como combustible. Era una ocasi√≥n de oro: pod√≠a aprovechar toda esa energ√≠a para aprender m√°s sobre la plataforma, explorar la comunidad de desarrollo de Game Boy y empaparme de su ecosistema. Mientras tanto, pod√≠a seguir procrastinando. No hacer el juego todav√≠a. Porque no estaba preparado, ¬øverdad?\nHabl√© con varias personas de la comunidad y les expliqu√© torpemente mi idea. Me dec√≠an que era casi imposible, que me olvidara y empezara por algo m√°s sencillo. Aquello fue, por supuesto, irresistible. ¬øQue no se puede? Ag√°rrame la birra.\nPero ten√≠an raz√≥n. Empec√© a probar distintos motores: GBDK, ZGB Engine (por entonces a√∫n no exist√≠a GB Studio). Pronto comprend√≠ que ninguno estaba pensado para lo que yo quer√≠a. No voy a entrar en detalles t√©cnicos de momento, pero en mi cabeza el juego mov√≠a montones de piezas sin restricci√≥n alguna, empuj√°ndose unas a otras y de manera fluida.\nCasi nada. Si quer√≠a sacarlo adelante, tendr√≠a que bajar a nivel de ensamblador. ¬°Qu√© pereza, por Dios! No tocaba ensamblador desde la universidad y, aunque t√©cnicamente me ve√≠a capaz de retomarlo, mi capacidad de procrastinaci√≥n es infinita. As√≠ que volv√≠ a lo de siempre: leer m√°s documentaci√≥n, ver m√°s ejemplos, ver m√°s v√≠deos, pensar estrategias para el motor de juego‚Ä¶ y no escribir ni una sola l√≠nea de c√≥digo.\n¬øY sabes qu√©? El m√©todo al final dio sus frutos, al menos si ignoras el peque√±o detalle de los siete a√±os que tard√© en empezar. Nadie dijo que fuera r√°pido üòÇ. Pero siendo sincero, no es que el m√©todo funcione con el tiempo: es que, en realidad, no funciona. La clave de mi ‚Äúsinergia motivacional‚Äù (tambi√©n conocida como evitaci√≥n sistem√°tica) es que nunca llegas a ejecutar la idea que te dio la motivaci√≥n inicial. Y, sin embargo, ese bucle interminable acab√≥ rompi√©ndose. No por m√≠, sino por la vida.\nDurante ese tiempo, mi carrera como full stack developer iba viento en popa, impulsada por la burbuja de las aplicaciones multiplataforma. Proyecto tras proyecto, sueldo tras sueldo, me fui hundiendo en una especie de workaholismo que no me dejaba tiempo para nada m√°s.\nHasta que, a principios de este a√±o (2025, para quien lea esto en plena era de la IA ‚Äîlo cual dudo bastante‚Äî), la burbuja estall√≥. Y con ello, mi empleo.\nCasi al mismo tiempo ocurri√≥ algo que, visto en retrospectiva, fue providencial. Un d√≠a, en una de mis en√©simas sesiones de investigaci√≥n rutinaria sobre c√≥mo podr√≠a hacer realidad mi juego, me top√© con una demo llamada Canyon Racer. Estaba hecha en GBDK ¬°yupi, sin ensamblador ! Lo importante es que esa demo ten√≠a la clave que har√≠a realidad mis fantas√≠as: c√≥mo variar la velocidad del scroll a mitad de scanline. ¬øPor qu√© era tan importante esto? Lo explicar√© en detalle en posts posteriores, pero resumiendo, el caso es que tras tantos a√±os de rumiar soluciones hab√≠a llegado a la conclusi√≥n de que ese truco gr√°fico era lo √∫nico que pod√≠a hacer posible mi juego imposible.\nY eso ten√≠a que ser la se√±al que llevaba a√±os esperando. Ya no me quedaban excusas. Estaba obligado a probar suerte.\nFue as√≠ como comenz√≥ mi periplo. Pero antes de hablar del proceso de desarrollo en s√≠, me gustar√≠a dedicar la siguiente entrada a explicar, a mi manera, las limitaciones gr√°ficas de la Game Boy. No ser√° un texto t√©cnico al uso, sino una explicaci√≥n personal de c√≥mo veo yo esa peque√±a m√°quina maravillosa.\nY si este texto sirve para que alguien m√°s se lance a la piscina, con suerte m√°s r√°pido de lo que lo hice yo, me dar√© por satisfecho.\nRecursos mencionados:\nAwesome Game Boy ¬∑ Gbdev Community ¬∑ GBDK 2020 ¬∑ RGBDS ¬∑ ZGB Engine ¬∑ GB Studio ¬∑ Canyon Racer\n","date":"17 octubre 2025","externalUrl":null,"permalink":"/es/posts/los-inicios-el-proyecto-que-nunca-empieza/","section":"Posts","summary":"De c√≥mo tarde 7 a√±os en empezar mi juego de Game Boy","title":"Los inicios: El proyecto que nunca empieza","type":"posts"},{"content":"","date":"17 octubre 2025","externalUrl":null,"permalink":"/es/tags/offtopic/","section":"Tags","summary":"","title":"Offtopic","type":"tags"},{"content":"Trabajo en Choco Charlie y otros proyectos de desarrollo indie. Estoy dispuesto a compartir mis peque√±os conocimientos de desarrollo retro con cualquiera que est√© interesado. ¬°No dudes en contactarme si quieres saber m√°s!\n","date":"17 octubre 2025","externalUrl":null,"permalink":"/es/","section":"TripleC Blog","summary":"","title":"TripleC Blog","type":"page"},{"content":"","externalUrl":null,"permalink":"/es/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/es/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]